# Paper Trading Engine Architecture

This document provides a detailed overview of the paper trading engine's architecture, which is responsible for simulating live trading based on the insights from the optimization engine.

## Components

The paper trading engine is composed of three main components:

1.  **Application Core (`web/backend/app.py`)**:
    *   **Initialization**: The `PaperTradingEngine` is initialized as a singleton when the main Flask application starts. It's provided with the application configuration, a `DataFetcher` for live price data, and an instance of the `TradingEngine`.
    *   **Background Tasks**: The application schedules two critical background tasks using `APScheduler`:
        *   `run_analysis_task`: This is the main trading logic task, running at a lower frequency (e.g., every 5 minutes).
        *   `run_price_monitoring_task`: This task runs at a higher frequency (e.g., every 15 seconds) to manage open positions.

2.  **Core Paper Trading Engine (`core/paper_trading_engine.py`)**:
    *   This is the brain of the paper trading system, encapsulated in the `PaperTradingEngine` class.
    *   **State Management**: It manages the entire state of the simulation, including the portfolio's capital, open positions, and a complete history of trades. This state is persisted to JSON files, allowing the engine to be resilient to restarts.
    *   **Trading Logic**: The engine's trading decisions are driven by the `analysis_task`, which:
        1.  Identifies the most volatile cryptocurrencies to monitor.
        2.  For each of these cryptos, it finds the most profitable trading strategies by querying the results from the optimization engine.
        3.  It fetches real-time price data.
        4.  It aggregates the trading signals from all the profitable strategies to make a final, consolidated trading decision (BUY, SELL, or HOLD).
        5.  It executes trades by simulating the opening and closing of positions.
    *   **Risk Management**: The `price_monitoring_task` is responsible for risk management. It continuously monitors open positions and automatically closes them if they hit their predefined stop-loss or take-profit levels.

3.  **API Layer (`web/backend/api/paper_trading.py`)**:
    *   This layer provides the HTTP interface for the frontend to interact with the paper trading engine.
    *   **`PaperTradingAPI`**: This endpoint provides a comprehensive, real-time snapshot of the paper trading engine's status, including open positions, portfolio value, trade history, and more.
    *   **`TradeHistoryAPI`**: This endpoint allows the frontend to retrieve detailed historical data about past trades.

## Workflow

The paper trading process follows this automated workflow:

1.  **Startup**: When the Flask application starts, it initializes the `PaperTradingEngine` and schedules the `analysis_task` and `price_monitoring_task` to run in the background.

2.  **Analysis Task (Lower Frequency)**: At a regular interval (e.g., every 5 minutes), the `analysis_task` executes its trading logic:
    *   It gets a list of the most volatile cryptocurrencies.
    *   For each of these, it identifies the best-performing strategies based on the latest optimization results.
    *   It fetches the latest price data for these cryptos.
    *   It generates a trading signal by aggregating the signals from the profitable strategies.
    *   If the signal is to enter a trade (BUY or SELL), it opens a new position.
    *   If the signal is to exit a trade, it closes the corresponding open position.

3.  **Price Monitoring Task (Higher Frequency)**: At a more frequent interval (e.g., every 15 seconds), the `price_monitoring_task` runs to manage risk:
    *   It gets the latest prices for all currently open positions.
    *   It checks if any position has hit its stop-loss or take-profit price.
    *   If a risk management threshold is triggered, it immediately closes the position.

4.  **Frontend API**: The frontend application can poll the `/api/paper-trading/status` endpoint to get real-time updates on the paper trader's performance and display this information to the user.

This architecture creates a robust and automated paper trading system that leverages the powerful insights generated by the optimization engine to make intelligent trading decisions in a simulated, real-time environment.


import logging
import time
import schedule
import threading
from datetime import datetime
import pandas as pd

from core.app_config import Config
from core.data_fetcher import get_crypto_data_merged, get_current_price
from pricer_compatibility_fix import find_best_result_file
from strategy import Strategy
from indicators import Indicators
from config import strategy_configs
import json
import os

class PaperTradingEngine:
    def __init__(self, config: Config):
        self.config = config
        self.total_capital = config.PAPER_TRADING_TOTAL_CAPITAL
        self.capital_per_trade = config.PAPER_TRADING_MIN_POSITION_VALUE
        self.max_concurrent_positions = int(self.total_capital / self.capital_per_trade)
        
        self.open_positions = []
        self.trade_history = []
        self.portfolio_value = self.total_capital
        
        # Ensure results directory exists
        os.makedirs(self.config.RESULTS_DIR, exist_ok=True)
        self.trades_log_path = os.path.join(self.config.RESULTS_DIR, 'paper_trades.json')

        logging.info("--- Paper Trading Engine Initialized ---")
        logging.info(f"Total Capital: ${self.total_capital:.2f}")
        logging.info(f"Capital per Trade: ${self.capital_per_trade:.2f}")
        logging.info(f"Max Concurrent Positions: {self.max_concurrent_positions}")

    def _get_volatile_cryptos(self):
        # Placeholder: In a real scenario, this would read a file generated by a discovery script
        # For now, we'll use a fixed list.
        # In the future, this will read from a file like 'data/volatile_cryptos.json'
        return ["bitcoin", "ethereum", "solana", "dogecoin"]

    def _get_best_strategy_and_params(self, crypto_id):
        best_file = find_best_result_file(crypto_id)
        if best_file and os.path.exists(best_file):
            with open(best_file, 'r') as f:
                data = json.load(f)
            
            strategy_name = data.get('strategy') or data.get('best_strategy')
            params = data.get('best_params') or data.get('params')

            if strategy_name and params:
                return strategy_name, params
        
        logging.warning(f"No best strategy found for {crypto_id}. Skipping.")
        return None, None

    def _get_trade_signal_for_latest(self, df: pd.DataFrame, strategy: Strategy, params: dict):
        try:
            long_entry, short_entry, long_exit, short_exit = strategy.generate_signals(df, params)
            if not long_entry.empty and long_entry.iloc[-1]:
                return "LONG"
            elif not short_entry.empty and short_entry.iloc[-1]:
                return "SHORT"
            else:
                return "HOLD"
        except Exception as e:
            logging.error(f"Error generating trade signal: {e}")
            return "HOLD"

    def analysis_task(self):
        logging.info("--- Running Analysis Task ---")
        
        if len(self.open_positions) >= self.max_concurrent_positions:
            logging.info("Max concurrent positions reached. Skipping new analysis.")
            return

        volatile_cryptos = self._get_volatile_cryptos()
        
        for crypto_id in volatile_cryptos:
            # Check if we have capacity for a new position
            if len(self.open_positions) >= self.max_concurrent_positions:
                break

            # Check if a position is already open for this crypto
            if any(p['crypto_id'] == crypto_id for p in self.open_positions):
                logging.info(f"Position already open for {crypto_id}. Skipping.")
                continue

            strategy_name, params = self._get_best_strategy_and_params(crypto_id)
            if not strategy_name or not params:
                continue

            # Fetch data (1 day of minute-level data)
            df = get_crypto_data_merged(crypto_id, days=1, config=self.config)
            if df is None or df.empty:
                logging.error(f"No data for {crypto_id}. Skipping.")
                continue

            # Get signal
            strategy_config = strategy_configs[strategy_name]
            indicators = Indicators()
            strategy = Strategy(indicators, strategy_config)
            signal = self._get_trade_signal_for_latest(df, strategy, params)

            logging.info(f"Signal for {crypto_id}: {signal}")

            if signal in ["LONG", "SHORT"]:
                self._open_position(crypto_id, signal, params)

    def _open_position(self, crypto_id, signal, params):
        current_price = get_current_price(crypto_id)
        if not current_price:
            logging.error(f"Could not fetch current price for {crypto_id} to open position.")
            return

        # Position sizing
        position_size_usd = self.capital_per_trade
        position_size_crypto = position_size_usd / current_price

        # Stop Loss
        stop_loss_percentage = params.get('fixed_stop_loss_percentage', 0.02) # Default 2%
        if signal == "LONG":
            stop_loss_price = current_price * (1 - stop_loss_percentage)
        else: # SHORT
            stop_loss_price = current_price * (1 + stop_loss_percentage)

        position = {
            "crypto_id": crypto_id,
            "signal": signal,
            "entry_price": current_price,
            "stop_loss_price": stop_loss_price,
            "size_usd": position_size_usd,
            "size_crypto": position_size_crypto,
            "timestamp": datetime.now().isoformat(),
            "status": "open"
        }

        self.open_positions.append(position)
        logging.info(f"Opened new {signal} position for {crypto_id} at ${current_price:.2f}. Stop loss at ${stop_loss_price:.2f}")
        self._save_trades()


    def price_monitoring_task(self):
        if not self.open_positions:
            return

        logging.info("--- Running Price Monitoring Task ---")
        
        for position in self.open_positions[:]: # Iterate over a copy
            current_price = get_current_price(position['crypto_id'])
            if not current_price:
                logging.warning(f"Could not fetch price for {position['crypto_id']} during monitoring.")
                continue

            logging.info(f"Monitoring {position['crypto_id']}: Current Price=${current_price:.2f}, SL=${position['stop_loss_price']:.2f}")

            stop_loss_triggered = False
            if position['signal'] == 'LONG' and current_price <= position['stop_loss_price']:
                stop_loss_triggered = True
            elif position['signal'] == 'SHORT' and current_price >= position['stop_loss_price']:
                stop_loss_triggered = True

            if stop_loss_triggered:
                self._close_position(position, current_price, "stop-loss")

    def _close_position(self, position, exit_price, reason):
        pnl_usd = 0
        if position['signal'] == 'LONG':
            pnl_usd = (exit_price - position['entry_price']) * position['size_crypto']
        else: # SHORT
            pnl_usd = (position['entry_price'] - exit_price) * position['size_crypto']

        self.portfolio_value += pnl_usd
        
        closed_trade = {
            **position,
            "exit_price": exit_price,
            "exit_timestamp": datetime.now().isoformat(),
            "pnl_usd": pnl_usd,
            "reason": reason,
            "status": "closed"
        }
        
        self.trade_history.append(closed_trade)
        self.open_positions.remove(position)

        logging.info(f"Closed {position['signal']} position for {position['crypto_id']} at ${exit_price:.2f} due to {reason}. PnL: ${pnl_usd:.2f}")
        logging.info(f"New Portfolio Value: ${self.portfolio_value:.2f}")
        self._save_trades()

    def _save_trades(self):
        try:
            all_trades = {
                "open_positions": self.open_positions,
                "trade_history": self.trade_history,
                "portfolio_value": self.portfolio_value
            }
            with open(self.trades_log_path, 'w') as f:
                json.dump(all_trades, f, indent=4)
        except Exception as e:
            logging.error(f"Failed to save trades log: {e}")

    def run(self):
        logging.info("Starting paper trading engine...")
        
        # Run analysis task once at the beginning
        self.analysis_task()

        # Schedule tasks
        schedule.every(30).minutes.do(self.analysis_task)
        schedule.every(1).minutes.do(self.price_monitoring_task)

        while True:
            schedule.run_pending()
            time.sleep(1)

def run_paper_trader():
    config = Config()
    # Add paper trading specific configs if they don't exist
    if not hasattr(config, 'PAPER_TRADING_TOTAL_CAPITAL'):
        config.PAPER_TRADING_TOTAL_CAPITAL = 470
    if not hasattr(config, 'PAPER_TRADING_MIN_POSITION_VALUE'):
        config.PAPER_TRADING_MIN_POSITION_VALUE = 50

    engine = PaperTradingEngine(config)
    
    # Run the engine in a separate thread
    engine_thread = threading.Thread(target=engine.run, daemon=True)
    engine_thread.start()

    logging.info("Paper trading engine is running in the background.")
    logging.info("Press Ctrl+C to stop.")
    
    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        logging.info("Stopping paper trading engine...")
        # The daemon thread will exit when the main thread exits
